%% Matlab Grid States, Choices and Optimal Choices Example
% *back to *<https://fanwangecon.github.io *Fan*>*'s *<https://fanwangecon.github.io/M4Econ/ 
% *Reusable Matlab*>* Repository or *<https://fanwangecon.github.io/CodeDynaAsset/ 
% *Dynamic Asset*>* Repository.*
%% *Generate State Grid*
% There many multiple individuals, each individual's value for each state space 
% variable is different. We duplicate that by shockCount and choicecount:

stateCount = 2;
shockCount = 3;
choiceCount = 4;

state1 = rand(1,stateCount)
states1ShkDup = state1(ones(shockCount*choiceCount,1),:)
states1ShkDup(:)
%% *Generate Choices*
% Generate Choice Grid, Example: Each individual has minimal protein and maximal 
% protein they can get Generate a evenly set grid of choices for each individual 
% from min to max. Individual min and max choice is a function of some component 
% of their state-space, such as wealth/income level, and choice is the quantity 
% of good to purchase.

stateCount = 2;
shockCount = 3;
choiceCount = 4;

% 1. Min and Max Choices for each state
minprot_n = floor(rand(1,stateCount)*10)
maxprot_n = minprot_n + floor(rand(1,stateCount)*10)
% 2. Choice Ratios, ratios of max-min difference
protChoiceGrid = linspace(0,1,choiceCount)
% 3. Each column is a different state.
searchMatrix = (protChoiceGrid'*(maxprot_n-minprot_n)+minprot_n(ones(choiceCount,1),:))
% 4. Each column is a different state, each set of rows is a different shock% for the state. In this structure, shocks (to preference for example), do% not change choice grid for a given state
searchMatrix = searchMatrix([1:choiceCount]'* ones(1,shockCount), [1:stateCount]' * ones(1,1))
searchMatrix(:)
%% *Average Utility over Shocks*
% Average of Shocks, E(value) For each STATE and CHOICE, x number of shocks. 
% Need to  average over shocks; The raw value output is: STATES * SHOCKS * CHOICES; 
% Code below turn into various things, see MATLAB CODE STRUCTURE in oneNOTE GCC 
% working notes

shockCount = 2;
choiceCount = 3;
stateCount = 4;

% 1. VALUE vector (STATES * SHOCKS * CHOICES by 1), this is generated by utility% evaluation function that takes as input STATES, SHOCKS, and CHOICES
valuesOri = sort(rand(choiceCount*shockCount*stateCount,1))
% 2. CHOICES by STATES * SHOCKS (ST1 SK1, ST1 SK2; ST2 SK1, etc), each% column are values for different choices given the same state and shock.
values = reshape(valuesOri,[choiceCount,shockCount*stateCount])
% 3. SHOCKS by CHOICES * STATES (CH1 ST1, CH1 ST2; CH2 ST1, etc), each% column are two shocks for each state given the same choice. Note this% assumes that for different shocks of the same state choice vector is the% same.
values = reshape(values',[shockCount, choiceCount*stateCount])
% 4. AVG: 1 by CHOICES * STATES (CH1 ST1, CH1 ST2; CH2 ST1, etc), take% average over shocks for each state and choice combo
valuesMn = mean(values,1)
% 5. AVG: CHOICES * STATES. From this matrix, one can now pick maximum% utility, and match that to the index on choice vector
valuesMn = reshape(valuesMn, [stateCount, choiceCount])'
%% *Pick Optimal Choice*

choiceCount = 3;
stateCount = 4;

% 1. Matrix, each column is a state, each row is a choice
randMat = rand(choiceCount,stateCount)
% 2. Maximum Value and Maximum Index
[maxVal maxIndex] = max(randMat)
% 3. Linear index
linearIdx = maxIndex + ((1:stateCount)-1)*choiceCount
% 4. Optimal Choices
randMat(linearIdx)